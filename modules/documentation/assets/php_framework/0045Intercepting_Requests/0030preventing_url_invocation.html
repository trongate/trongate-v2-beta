<h1>Preventing URL Invocation</h1>
<p>Want a method that runs in code — but <strong>never</strong> from a browser? <strong>Prefix it with an underscore.</strong></p>
<p><strong><span style="color: red;">No config. No middleware. No YAML.</span></strong></p>
<p>Just <strong>Native PHP</strong> doing what it was born to do.</p>

<hr>

<h2 class="mt-0">How It Works</h2>
<p>Any method starting with <code>_</code> is <strong>blocked from URLs</strong> — but is still callable in your app.</p>

[code=php]
&lt;?php
class Orders extends Trongate {

    public function create() {
        $this->_validate();
        echo 'Order created!';
    }
    public function _validate() {
        // secret sauce
    }

}
[/code]

<p>With the code that's displayed above:</p>
<ul style="margin: 0 auto; width:max-content;">
    <li><code>yoursite.com/orders/create</code> → works</li>
    <li><code>yoursite.com/orders/_validate</code> → <strong>404</strong></li>
    <li><code>$this->_validate()</code> → <strong>allowed, but only if called from code</strong></li>
</ul>

<div class="alert alert-info">
    <p><strong>Myth bust:</strong> <code>_method()</code> is <strong>not</strong> <code>private</code>.</p>
    <p>It’s still a <strong>public</strong> method — but it's hidden from the browser.</p>
    <p>Just to underline the point, consider the following (valid and acceptable) code sample:</p>
[code=php]
/*
  This method CANNOT be invoked from the URL.
  However, it CAN be called from other modules (because it's 'public').
*/
public function _greeting() {
    echo 'hello world';
}
[/code]
</div>

<hr>

<h2 class="mt-0">Call It From Anywhere</h2>
<p>Modules are friends. Even if a method name starts with an underscore - it can still be called from anywhere in your application. For example, from any controller:</p>

[code=php]
// Load and use a 'cart' module (with one line of code!)
$total = $this->cart->_calculate_total();
[/code]

<p>Or, from inside any view:</p>

[code=php]
<div><?= Modules::run('cart/_draw_shopping_cart') ?></div>
[/code]

<hr>

<div class="alert alert-success">
    <p><strong>Preventing Cross-Module Invocation</strong></p>
<p>The underscore prefix blocks <strong>URL access</strong> but still allows methods to be called from anywhere in your application (other modules, views, etc.) because they remain <code>public</code>.</p>
    <p><strong>If you want to prevent other modules from calling a method entirely</strong>, make it <code>private</code>:</p>

    [code=php]
&lt;?php
class Orders extends Trongate {

    public function create() {
        $this->validate_order(); // OK
        echo 'Order created!';
    }

    // Blocked from URLs
    // Callable from other modules
    public function _calculate_total() {
        return $this->apply_tax(100);
    }

    // Blocked from URLs
    // Blocked from other modules
    // Only usable inside Orders
    private function validate_order() {
        // secret sauce
    }

    private function apply_tax($amount) {
        return $amount * 1.2;
    }
}
[/code]

    <p class="text-center"><strong><code>public _method()</code> → URL-only block<br>
    <code>private method()</code> → total lockdown</strong></p>

    <p><strong>Use <code>private</code> when no one — not even other modules — should touch it.</strong></p>
</div>

<p class="text-center mt-3"><strong>Now, let's discuss how to deal with CORS shenanigans...</strong></p>